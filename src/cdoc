#!/usr/bin/perl -w

use Text::Markdown 'markdown';

our $state = 'null';
our $data  = '';
our @stream = ();
our %frag = ();

sub fragments()
{
	my %h = ();
	my $key = ''; my $val = '';
	while (<DATA>) {
		if (m/^-[a-z]+-{6,}/) {
			if ($val ne '') { $h{$key} = $val; }

			chomp;
			s/^-([a-z]+)-{6,}/$1/;
			$key = $_;
			$val = '';
			next;
		}
		$val .= $_;
	}
	if ($val ne '') { $h{$key} = $val; }
	close DATA;
	return %h;
}

sub putfile($$)
{
	my $file = shift;
	my $data = shift;

	open  $fh, ">$file";
	print $fh $data;
	close $fh;
}

sub is_typedef_struct($)
{
	$_ = shift;
	return m/^typedef\s+struct/;
}

sub is_struct($)
{
	$_ = shift;
	return m/^struct\s+\S+\s*{/;
}

sub is_macro($)
{
	$_ = shift;
	return m/^#define \w+\s*\(/;
}

sub proto($)
{
	$_ = shift;
	if (is_typedef_struct $_) {
		s/\s*{.*}\s+(\w+);.*/ { ... } $1/s;
		return $_;
	}
	if (is_macro $_) {
		s/^#define\s*([^\)]+\)).*/$1/s;
		return $_;
	}
	s/\s+{.*//s;
	return $_;
}

sub objkey($)
{
	$_ = shift;
	if (is_typedef_struct $_) {
		s/typedef\s+struct\s+{.*}\s+(\w+);.*/$1/s;
		return $_;
	}
	if (is_struct $_) {
		s/\s+{.*//s;
		return $_;
	}
	if (is_macro $_) {
		s/^#define\s*([^\(]+)\(.*/$1/s;
		return $_;
	}
	#if (m/^struct\s+\S+$/) { return $_; }
	s/\s+{.*//s;
	s/\s*\(.*//;
	s/.*\s+\**//;
	return $_;
}

sub key2id($)
{
	$_ = shift;
	s/\s+/-/g;
	return $_;
}

sub pretty($)
{
	$_ = shift;
	s/\$([a-zA-Z0-9_]+)/<var>$1<\/var>/g;
	s/<code>/<pre><code>/g;
	s/<\/code>/<\/code><\/pre>/g;
	s/(<pre><code>)\s*\n/$1/gs;
	s/\s*\n\s*(<\/code><\/pre>)/$1/gs;
	return markdown($_);
}

sub summary($)
{
	$_ = shift;
	s/\n\n+.*//s;
	return $_;
}

sub detail($)
{
	$_ = shift;
	s/[^\n]*\n\n+//;
	return $_;
}

sub mapstream
{
	my %map = ();
	my $h; my $k;
	my $comment = '';
	my $file = '';
	my $line = 0;

	for (@_) {
		my ($op, $s) = @{$_};
		if ($op eq 'comment') {
			$comment = $s;
		} elsif ($op eq 'file') {
			$file = $s;
		} elsif ($op eq 'line') {
			$line = $s;
		} elsif ($comment ne '') {
			$h = {};
			$k = objkey($s);
			if (is_typedef_struct($s) or is_struct($s)) {
				$h->{type} = 'struct';
				$k = "001:$k";
			} else {
				$h->{type} = 'function';
				$k = "050:$k";
			}
			$h->{file}      = $file;
			$h->{line}      = $line;
			$h->{summary}   = summary($comment);
			$h->{comment}   = detail($comment);
			if ($h->{comment} eq $h->{summary}) {
				$h->{comment} = '';
			}
			$h->{prototype} = proto($s);
			$h->{code}      = $s;
			$map{$k} = $h;

			$comment = '';
		}
	}

	return %map;
}

sub parsefile($)
{
	my $file = shift;

	push @stream, ['file', $file];
	my $io;
	open  $io, "<$file";
	parse($io);
	close $io;
}

sub parse($)
{
	my $io = shift;
	my $n = 0; my $line = 0;
	my $type = '';
	my $proto = '';

	while (<$io>) {
		$n++;
		s/\r//g;
		if (m/^\/\*\*/) { # are we at the start of a comment?
			s/^\/\*\*\s+//;
			if (m/\*\/$/) { # is it a single-line comment?
				s/\s*\*\/$//;
				push @stream, ['comment', $_];
				$state = 'code'; $data = ''; $line = $n;
			} else {
				$state = 'comment';
				$data = '';
			}
			next;
		}

		if ($state eq 'comment') {
			if (m/^\s*\*\/$/) {
				push @stream, ['comment', $data];
				$state = 'code'; $data = ''; $line = $n;
				next;
			}
			$data .= $_;
			next;
		}

		if ($state eq 'code') {
			if ($data eq '') {
				$type = m/^#define/ ? 'macro' : 'other';
			}
			$data .= $_;
			if (($type ne 'macro' and /^}(\s+\w+)?;?$/)
			 || ($type eq 'macro' and /^\s*$/)) {
				push @stream, ['line', $line+1];
				push @stream, ['code', $data];

				$proto = objkey($data);
				print STDERR "  - $proto\n";

				$state = 'null'; $data = '';
				next;
			}
		}
	}

	$state = 'null'; $data = '';
}

sub output()
{
	print $frag{header};
	my %map = mapstream(@stream);
	for my $name (sort keys %map) {
		my %o = %{$map{$name}};
		$name =~ s/.\d+://;

		$o{comment} = pretty($o{comment});
		$o{summary} = pretty($o{summary});
		$o{summary} =~ s/<p>/<p class="summary">/;

		print "    <div class=\"doc $o{type}\" id=\"", key2id($name), "\">\n";
		print "      <h2>$name</h2>\n\n";
		if ($o{type} ne 'struct') {
			print "      <p class=\"prototype\">$o{prototype}</p>\n\n";
		}
		print $o{summary};
		if ($o{type} eq 'struct') {
			print "      <pre class=\"struct\">$o{code}</pre>\n";
		}
		print $o{comment};
		print "\n";
		if ($o{type} ne 'struct') {
			print "      <a href=\"#\" class=\"source\"><code>$o{file}:$o{line}</code></a>\n";
			print "      <pre class=\"source\" id=\"src_$name\"><code>$o{code}</code></pre>\n\n";
		} else {
			print "      <code>$o{file}:$o{line}</code>\n";
		}
		print "    </div>\n\n";
	}
	print $frag{footer};
}

for my $f (@ARGV) {
	print STDERR "> $f...\n";
	parsefile($f);
}

%frag = fragments();
output();
putfile "cdoc.css", $frag{css};
putfile "cdoc.js",  $frag{js};

__DATA__
-header-----------------------------------------------------------
<!DOCTYPE html>
<html>
<head>
  <title>Clockwork API Docs</title>
  <link rel="stylesheet" type="text/css" href="cdoc.css" />
</head>
<body class="api">
  <h1 id="title"><span>Clockwork API Docs</span></h1>
  <div id="s">
    <ul class="nav">
      <li><a href="/">Home</a></li>
      <li><a href="/downloads/">Downloads</a></li>
      <li><a href="/docs/">Documentation</a></li>
      <li><a href="/roadmap">Roadmap</a></li>
      <li><a href="/contact">Feedback</a></li>
    </ul>
  </div>
  <div id="m">
-footer-----------------------------------------------------------
  </div>
  <script type="text/javascript" src="cdoc.js"></script>
</body>
</html>
-css--------------------------------------------------------------
/* INSERT CSS */
-js---------------------------------------------------------------
/* INSERT JS */
